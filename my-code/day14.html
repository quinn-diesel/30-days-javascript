<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
</head>
<body>

  <script>
    // start with strings, numbers and booleans

    // let age = 100;
    // let age2 = age;
    // console.log(age, age2);
    //
    // age = 200;
    // console.log(age, age2);
    //
    // // the value of age of age goes into the variable at teh same time
    //
    // let name = 'Wes';
    // let name2 = name;
    // console.log(name, name2);
    //
    // name = 'wesley';
    // console.log(name, name2);

    // Let's say we have an array
    // const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
    //
    // const team  = players;
    //
    // console.log(players, team);

    // team[5] = 'Lux';


    // and we want to make a copy of it.

    // const team2 = players.slice();
    //
    // const team3 = [].concat(players.slice());

    // You might think we can just do something like this:

    // however what happens when we update that array?

    // now here is the problem!

    // oh no - we have edited the original array too!

    // Why? It's because that is an array reference, not an array copy. They both point to the same array!

    // So, how do we fix this? We take a copy instead!

    // one way

    // or create a new array and concat the old one in

    // or use the new ES6 Spread

      // a spread will take out every item of your iterable to spread into a function

      // const team = [...players];
      // team [5] = 'heee haww';
      //
      // console.log(team4);
      //
      // const team5 = Array.from(players)

    // now when we update it, the original one isn't changed

    // The same thing goes for objects, let's say we have a person object

    // with Objects

    const person = {
      name: 'Wes Bos',
      age: 80
    }


    // and think we make a copy:

    const captain = person;
    captain.number = 99;

    // how do we take a copy instead?

    // going to start with the blank array, then you are going to choose the one you want to manipulate and finish off the aspect that you want to add
    const cap2 = Object.assign ({}, person, { number: 99, age: 12 });


    // We will hopefully soon see the object ...spread

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

    const wes = {
      name = 'quinn',
      age: 25,
      social: {
        twitter: '@quinntorious',
        facebook: 'randomfact'
      }
    }

    console.clear();
    console.log(wes);

    // this is taking a copy of the object and updating to a new one
    // object.assign will only go one level deep or you could always just use clone deep
    const dev = Object.assign({}, wes);


    // poor man's deep close
    // stringify will return a string and the parse will change it back into the object and therefore enable you to make the changes 
    const dev2 = JSON.parge(JSON.stringify(wes));



  </script>

</body>
</html>
